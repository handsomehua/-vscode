{
    //------------------------------调试--------------------------------------------
    "fmt.Print打印": {
        "prefix": "!~",
        "body": [
            "fmt.Print(\"你的等级是\", \"a\") //你的等级是a"
        ]
    },
    "fmt.Println打印": {
        "prefix": "!~ln",
        "body": [
            "//1.打印整数\n fmt.Println(1)\n\n //2.打印字符串\n fmt.Println(\"str\")\n\n//3.打印字符串\nfmt.Println(\"我叫jch\", \"我媳妇是个\", \"...\")\n\n//4.打印数组\n arr2 := [3]int{1, 2, 5}\n fmt.Println(arr2)\n\n//错误语法\n//fmt.Println('str')"
        ]
    },
    "fmt.Printf占位符拼接打印": {
        "prefix": "!~f",
        "body": [
            "fmt.Printf($1)"
        ]
    },
    "fmt.Sprintf拼接并返回不打印": {
        "prefix": "!~sf",
        "body": [
            "//示例1\n //Sprintf是将拼接的字符串返回\n aa := fmt.Sprintf(\"我叫%s,在%s\", \"sfd\", \"sfd\")\n if aa == \"我叫sfd,在sfd\" {\n fmt.Print(1)\n }\n \n //示例2\n var name, address, action string\n fmt.Println(\"请输入姓名：\")\n fmt.Scanln(&name)\n \n fmt.Println(\"请输入位置：\")\n fmt.Scanln(&address)\n \n fmt.Println(\"请输入行为：\")\n fmt.Scanln(&action)\n result := fmt.Sprintf(\"我叫%s,在%s正在%s\", name, address, action)\n //打印\n fmt.Println(result)\n"
        ]
    },
    "%占位符打印": {
        "prefix": "!~%",
        "body": [
            "//占位符\n //%s，占位符 \"文本\"\n //%d，占位符 整数\n //%f，占位符 小数（浮点数）\n //%.2f，占位符 小数（保留小数点后2位，四舍五入）\n //100%%，百分比\n//v% 可以字符串 整型  浮点型 3.889\n fmt.Printf(\"老汉开着%s,去接%s的媳妇，多少钱一次？%d块。嫂子给打折吧，%.2f怎么样？小哥哥包你100%%满意%v\", \"车\", \"老男孩\", 100, 3.889, 3.889)"
        ]
    },
    "fmt.Printf打印类型": {
        "prefix": "!~t",
        "body": [
            "fmt.Printf(\"type of :%T\\n\", 1) //type of :int"
        ]
    },
    "reflect.TypeOf返回类型": {
        "prefix": "!~TypeOf",
        "body": [
            "//reflect.TypeOf()返回类型不打印\n var v3 int16 = 100\n fmt.Println(reflect.TypeOf(v3))//int16"
        ]
    },
    "fmt.Printf打印值": {
        "prefix": "!~v",
        "body": [
            "fmt.Printf(\"type of :%v\\n\", \"高富帅\") //type of :高富帅"
        ]
    },
    "%p打印内存地址": {
        "prefix": "!~p",
        "body": [
            "//打印内存地址\n nums := [3]int8{11, 22, 33}\n fmt.Printf(\"数组的内存地址：%p \\n\", &nums)//与&nums[0]地址相同\n //数组的地址，是数组的第一个元素地址\n // fmt.Printf(\"数组的内存地址：%p \\n\", &nums[0])\n // fmt.Printf(\"数组的内存地址：%p \\n\", &nums[1])\n // fmt.Printf(\"数组的内存地址：%p \\n\", &nums[2])\n"
        ]
    },
    "continue跳出本次循环": {
        "prefix": "!~continue",
        "body": [
            "for i := 1; i < 5; i++ {\n if i == 3 {\n continue\n }\n fmt.Println(i)\n }\n"
        ]
    },
    "break跳出循环": {
        "prefix": "!~break",
        "body": [
            "for i := 1; i < 5; i++ {\n if i == 3 {\n break\n }\n fmt.Println(i)\n }\n"
        ]
    },
    "print打印^": {
        "prefix": "!~^print",
        "body": [
            "//不推荐使用\nprint(\"高富帅\")\nprint(\"高富帅\")"
        ]
    },
    "println打印^": {
        "prefix": "!~^println",
        "body": [
            "//不推荐使用\nprintln(\"高富帅\")\nprintln(\"高富帅\")"
        ]
    },
    "暂停代码执行": {
        "prefix": "!~time",
        "body": [
            "//示例一\n for i := 0; i < 10; i++ {\n fmt.Println(\"你好golang\")\n time.Sleep(time.Millisecond * 1000) //每隔1秒输出一次golang\n }\n \n //示例二\n //一秒后执行代码\n time.Sleep(time.Millisecond * 1000) //1000毫秒=1秒\n fmt.Println(\"你好\")\n"
        ]
    },
    "程序执行时间": {
        "prefix": "!~time",
        "body": [
            "package main\n \n import (\n \"fmt\"\n \"sync\"\n \"time\"\n )\n \n var wg sync.WaitGroup\n \n func main() {\n \n start := time.Now().Unix()\n for num := 2; num < 120000; num++ {\n var flag = true\n for i := 2; i < num; i++ {\n if num%i == 0 {\n flag = false\n break\n }\n }\n if flag {\n // fmt.Print(num, \"是素数\\n\")\n \n }\n \n }\n end := time.Now().Unix()\n \n fmt.Println(end - start) //3毫秒\n \n }\n"
        ]
    },
    "铺获error继续执行代码+": {
        "prefix": "!~err",
        "body": [
            "package main\n \n import (\n \"fmt\"\n \"time\"\n )\n \n //函数\n func sayHello() {\n for i := 0; i < 10; i++ {\n time.Sleep(time.Millisecond * 50)\n fmt.Println(\"hello,world\")\n }\n \n }\n \n //函数\n func test() {\n //如果没有铺获异常，报错代码会终止执行\n //这里我们可以使用defer + recover\n defer func() {\n //铺获test抛出的panic\n if err := recover(); err != nil {\n fmt.Println(\"test() 发生错误\", err)\n }\n }()\n var myMap map[int]string\n myMap[0] = \"golang\" //error\n }\n \n func main() {\n go sayHello()\n go test()\n //等待协程执行完\n time.Sleep(time.Second)\n }\n"
        ]
    },
    "空接口反射打印变量类型+": {
        "prefix": "!~TypeOf",
        "body": [
            "package main\n \n import (\n \"fmt\"\n \"reflect\"\n )\n \n type myInt int\n type Person struct {\n Name string\n Age  int\n }\n \n func reflectFn(x interface{}) {\n v := reflect.TypeOf(x)\n // v.Name() //类型名称\n // v.Kind() //种类\n fmt.Printf(\"类型:%v 类型名称:%v 类型种类:%v \\n\", v, v.Name(), v.Kind())\n }\n \n func main() {\n a := 10\n b := 23.4\n c := true\n d := \"你好golang\"\n reflectFn(a)\n reflectFn(b)\n reflectFn(c)\n reflectFn(d)\n \n var e myInt = 34\n var f = Person{\n Name: \"张三\",\n Age:  20,\n }\n reflectFn(e)\n reflectFn(f)\n \n var h = 25\n reflectFn(&h)\n \n var i = [3]int{1, 2, 3}\n reflectFn(i)\n \n var j = []int{11, 22, 33}\n reflectFn(j)\n \n }\n"
        ]
    },






























    //------------------------------GO语法-------------------------------------------
    "GO数据类型": {
        "prefix": ":~go",
        "body": [
            "//整型\n fmt.Println(6 + 9)\n fmt.Println(6 - 9)\n fmt.Println(6 * 9)\n fmt.Println(6 / 9)\n fmt.Println(16 % 9) //余数\n\n //字符串类型\n fmt.Println(\"武沛齐\")\n fmt.Println(\"alex\" + \"SB\")\n fmt.Println(\"1\" + \"2\") //2\n //错误语法\n //fmt.Println(\"alex\" + 666)\n\n //布尔类型\n fmt.Println(1 > 2)  //false\n fmt.Println(1 < 2)  //true\n fmt.Println(1 == 2) //false\n fmt.Println(1 >= 2) //false\n fmt.Println(1 <= 2) //true\n"
        ]
    },
    "GO变量 声明 赋值 简写 规范": {
        "prefix": ":~go",
        "body": [
            "//变量要求\n //1.变量创建规则：以字母 数字 下划线组合创建\n //2.数字不能开头\n//3.变量使用小驼峰法命名：myName\n//4.不能使用的命名关键字\n //break        default      func         interface    select\n //case         defer        go           map          struct\n //chan         else         goto         package      switch\n //const        fallthrough  if           range        type\n //continue     for          import       return       var  \n//1.字符串变量\n var sd string = \"老男孩alex\"\n fmt.Println(sd)\n \n //2.整型变量\n var age = 73 - 70\n fmt.Println(age)\n \n //3.布尔型变量\n var flag bool = true\n fmt.Println(flag)\n\n //声明 + 赋值\n var hua string\n hua = \"华\"\n fmt.Println(hua)\n//简写变量1\n name := \"武沛齐\" //推荐\n var status, message, data string\n fmt.Println(name, status, message, data)\n //简写变量2\n var (\n number = 10\n gender string //不赋值，默认 \"\"\n length int    //不赋值，默认 0\n sb     bool   //不赋值，默认 false\n)\n fmt.Println(number, gender, length,sb)\n//简写变量3\n v1, v2 := 11, 22\n fmt.Println(v1, v2)\n fmt.Println(v1, v2)\n //简写变量4\n v3, v4 := 11, 22\n v5 := 666\n v3, v4, v5 = 16, 100, 888 //给多个变量赋值\n fmt.Println(v3, v4, v5)\n"
        ]
    },
    "GO变量作用域+": {
        "prefix": ":~go",
        "body": [
            "//变量作用域\n //1.括号内定义的变量，只能被同级和下级使用\n name := \"武沛齐\"\n if true {\n age := 18\n name := \"alex\"\n fmt.Println(age)\n fmt.Println(name)\n }\n fmt.Println(name)\n //错误语法\n //fmt.Println(age)\n"
        ]
    },
    "GO全局变量 局部变量+": {
        "prefix": ":~go",
        "body": [
            "package main\n \n import \"fmt\" \n //全局变量\n var school string = \"蒋郴华\"\nvar status = 1\n var message = \"sb\"\n \nvar (\n v1 = 123\n v2 = \"你好\"\n v3 int\n )\n \n //错误语法\n //school2 := \"jiangchenhua\" //不能用省略定义\n \n func main() {\n //局部变量\n name := \"jch\"\n fmt.Println(name)\n //打印全局变量\n fmt.Println(school)\nfmt.Println(status)\n fmt.Println(message)\nfmt.Println(v1, v2, v3)\n}\n"
        ]
    },
    "GO全局常量 局部常量": {
        "prefix": ":~go",
        "body": [
            "package main\n import \"fmt\"\n //全局常量\n const (\n pi     = 3.124\n gender = \"男\"\n )\n \n func main() {\n //常量定义了不能修改\n //一般常量定义都是全局的\n //局部常量\n const age = 18\n const name = \"蒋郴华\"\n const (\n v1 = 123\n v2 = 456\n )\n \n fmt.Println(v1, v2)\n fmt.Println(age, name)\n //错误语法\n // const name1 int //const ( name2 int)\n \n //打印全局常量\n fmt.Println(pi, gender)\n }\n"
        ]
    },
    "GO传值 拷贝传值+": {
        "prefix": ":~go",
        "body": [
            "//拷贝传递\n//int string bool这三种类型则会拷贝一份？？？\n name := \"蒋郴华\"\n nickname := name\n //&表示内存地址\n fmt.Println(name, &name)\n fmt.Println(nickname, &nickname)\n \n //覆盖name地址不变\n name = \"jch\"\n fmt.Println(name, &name)\n"
        ]
    },
    "GO运算符 运算符优先级": {
        "prefix": ":~go",
        "body": [
            "//运算符\n //算数运算符：+ - * / % ++ --\n //关系运算符：== != > < >= <=\n //逻辑运算符：&& || !\n//位运算符：（也叫进制运算符用不上）\n //赋值运算符：= += -= *= /=\n\n//运算符优先级 (6->5->4->3->2->1)\n // 6 加括号优先级最高 ()\n// 5             *  /  %  <<  >>  &  &^\n // 4             +  -  |  ^\n // 3             ==  !=  <  <=  >  >=\n // 2             &&\n // 1             ||\n"
        ]
    },






















































    //------------------------------GO函数-------------------------------------------
    "用户输入fmt.Scan": {
        "prefix": "*~Scan",
        "body": [
            "//fmt.Scan和fmt.Scanln区别就是一个没有输完回车会一直等待，另一个回车就算全部输完了\n//Scan用户输入\n //示例1：fmt.Scan\n // var name string\n // fmt.Println(\"请输入用户名：\")\n // fmt.Scan(&name)\n // fmt.Println(name)\n \n //示例2：fmt.Scan\n var name string\n var age int\n fmt.Println(\"请输入用户名：\")\n //count表示用户输入对了几个值,好比如:输对了用户名 输错了age 那么count为1  两个都输对了count为2\n //err用户输入错误，包含的错误信息\n count, err := fmt.Scan(&name, &age)\n if err == nil {\n fmt.Println(name, age)\n } else {\n fmt.Println(\"用户输入数据错误\", err)\n fmt.Println(\"输对了数量\", count)\n }\n //特别说明：fmt.Scan要求输入两个值，必须输入两个，否则他会一直等待\n\n\n\n//缺陷：无法获取空格后的内容\n//var message string\n //fmt.Print(\"请输入个人信息\")\n //fmt.Scan(&message)\n //fmt.Println(message)\n"
        ]
    },

    "用户输入(推荐)fmt.Scanln": {
        "prefix": "*~Scanln",
        "body": [
            "//fmt.Scan和fmt.Scanln区别就是一个没有输完回车会一直等待，另一个回车就算全部输完了\n //Scanln用户输入\n //示例1：Scanln\n // var name string\n // fmt.Print(\"请输入用户名：\")\n // fmt.Scanln(&name)\n // fmt.Println(name)\n \n //示例2：fmt.Scan\n var name string\n var age int\n fmt.Print(\"请输入用户名：\")\n //count表示用户输入对了几个值,好比如:输对了用户名 输错了age 那么count为1  两个都输对了count为2\n //err用户输入错误，包含的错误信息\n count, err := fmt.Scanln(&name, &age)\n if err == nil {\n fmt.Println(name, age)\n } else {\n fmt.Println(\"用户输入数据错误\", err)\n fmt.Println(\"输对了数量\", count)\n }\n //特别说明：fmt.Scanln 回车就算两个值输完了\n\n\n\n//缺陷：无法获取空格后的内容\n//var message string\n //fmt.Print(\"请输入个人信息\")\n //fmt.Scanln(&message)\n //fmt.Println(message)\n"
        ]
    },
    "读取用户输入内容包括空格后内容": {
        "prefix": "*~Stdin",
        "body": [
            "//os.Stdin 理解为：标准输入 或 或输入存储的文件\n //bufio.NewReader() 读取文件内容\n //reader.ReadLine() 读取文件一行内容\n reader := bufio.NewReader(os.Stdin)\n //#line,从stdin中读取一行数据,返回字节集合\n //#isPrefix 是否读完 （reader默认一次只能读4096个字节） 读完返回false\n //# line, isPrefix, err := reader.ReadLine()\n \n line, _, _ := reader.ReadLine()\n \n data := string(line)\n fmt.Print(data)\n"
        ]
    },
    "SetString存储超大整型": {
        "prefix": "*~SetString",
        "body": [
            "//存储超大整型\n v1 := new(big.Int)\n //不建议创建方式 var v1 big.Int \n //不建议使用v1.SetInt64() 原因不能超过19位\n //建议使用SetString()\n v1.SetString(\"4411341541831321535151351231\", 10)\n fmt.Println(v1)\n //SetString可以将二进制转十进制存储到内存中\n v1.SetString(\"0101000110\", 2)\n fmt.Println(v1)\n"
        ]
    },
    "计算字符串长度任意字符为1": {
        "prefix": "*~utf8",
        "body": [
            "//计算字符串长度任意字符为1\n name := \"蒋郴华3~.\"\n runeLength := utf8.RuneCountInString(name)\n fmt.Println(runeLength)\n"
        ]
    },
    "查找一段字符串中是否存在'老子'": {
        "prefix": "*~strings",
        "body": [
            "//查找一段字符串中是否存在\"老子\"\n name3 := \"抬老子的意大利炮来\"\n result3 := strings.Contains(name3, \"老子\")\n fmt.Println(result3) //true\n"
        ]
    },
    "去两边空格": {
        "prefix": "*~Trim",
        "body": [
            "//去两边空格\n result8 := strings.Trim(\"  jiangchenhua             \", \" \")\n fmt.Println(result8)\n"
        ]
    },
    "字符串替换": {
        "prefix": "*~Replace",
        "body": [
            "//字符串替换\n name6 := \"wupeipeiqi\"\n result7 := strings.Replace(name6, \"pei\", \"PE\", 1)  //找到pei替换为PE,替换前一个\n result8 := strings.Replace(name6, \"pei\", \"PE\", 2)  //找到pei替换为PE,替换前两个\n result9 := strings.Replace(name6, \"pei\", \"PE\", -1) //替换所以的pei\n fmt.Println(result7, result8, result9)\n"
        ]
    },
    "字符串分割成数组": {
        "prefix": "*~Split",
        "body": [
            "//字符串分割成数组\n name7 := \"抬老子的意大利炮来\"\n result7 := strings.Split(name7, \"的\")\n fmt.Println(result7) //[抬老子 意大利炮来]\n \n"
        ]
    },
    "效率最高的字符串拼接": {
        "prefix": "*~builder",
        "body": [
            "//建议推荐使用：效率更更更高一些（go 1.10之后）\n //以下是字符串拼接效率最高的\n var builder strings.Builder\n builder.WriteString(\"哈哈哈\")\n builder.WriteString(\"去你的吧\")\n value := builder.String()\n fmt.Println(value)\n"
        ]
    },
    "获取长度": {
        "prefix": "*~len",
        "body": [
            "v1 := make([]int, 1, 3)\n //len 获取长度\n fmt.Println(len(v1))\n"
        ]
    },
    "获取容量": {
        "prefix": "*~cap",
        "body": [
            "v1 := make([]int, 1, 3)\n //cap 获取容量\n fmt.Println(cap(v1))\n"
        ]
    },
    "切片入栈追加": {
        "prefix": "*~append",
        "body": [
            "//方法一\n //append可以插入一个或多个\n v1 := make([]int, 1, 3)\n v2 := append(v1, 90)\n fmt.Println(v1, v2)\n \n //方法二\n /*必须是切片数组*/\n var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n s1 := arr[2:6]\n s4 := append(s1, 11, 12)\n fmt.Println(s4)\n\n//方法三\n gg1 := []int{11, 22, 33}\n gg2 := append(gg1, []int{100, 200, 300}...)\n fmt.Println(gg2)\n"
        ]
    },
    "获取指针下一个元素的值+": {
        "prefix": "*~unsafe",
        "body": [
            "dataList := [3]int8{11, 22, 33}\n \n //1.获取数组第一个元素的地址（指针）\n var firstDataPtr *int8 = &dataList[0]\n \n //2.转换成Pointer类型\n ptr := unsafe.Pointer(firstDataPtr)\n \n //3.转换成uintptr类型，然后进行内存地址的计算（即：地址加1个字节，意味着取第二个索引位置的值）。\n targetAddress := uintptr(ptr) + 1\n \n //4.根据新地址，重新转换成Pointer类型\n newPtr := unsafe.Pointer(targetAddress)\n \n //5.Pointer对象转换为int8指针类型\n value := (*int8)(newPtr)\n \n //6.根据指针获取值\n fmt.Println(\"最终结果为：\", *value)\n"
        ]
    },
    "json序列化数据+": {
        "prefix": "*~json",
        "body": [
            "package main\n \n import (\n \"encoding/json\"\n \"fmt\"\n )\n \n type Person struct {\n Name string\n Age  int\n }\n \n func main() {\n v1 := []interface{}{\n \"武沛齐\",\n 123,\n true,\n 4.13,\n Person{\"HUA\", 18},\n map[string]interface{}{\n \"name\": \"weipeiqi\",\n \"age\":  18,\n },\n }\n res, _ := json.Marshal(v1)\n data := string(res)\n fmt.Println(data) //[\"武沛齐\",123,true,4.13,{\"Name\":\"HUA\",\"Age\":18},{\"age\":18,\"name\":\"weipeiqi\"}]\n }\n"
        ]
    },
    "json反序列化数据": {
        "prefix": "*~json",
        "body": [
            "//序列化一般是http请求用\n//结构体反序列化是map\n content := `[\"武沛齐\",123,true,4.13,{\"Name\":\"HUA\",\"Age\":18},{\"age\":18,\"name\":\"weipeiqi\"}]`\n \n var value []interface{}\n \n json.Unmarshal([]byte(content), &value)\n \n fmt.Println(value)\n"
        ]
    },
    "赋值通过指针同步修改": {
        "prefix": "*~*&",
        "body": [
            "//通过指针实现同步修改\n type Person struct {\n hobby  *[2]string\n hobby2 [2]string\n }\n p1 := Person{\n hobby:  &[2]string{\"裸奔\", \"大保健\"}, //同步修改\n hobby2: [2]string{\"裸奔\", \"大保健\"},  //拷贝\n }\n p2 := p1\n \n p1.hobby[0] = \"搓澡\"\n p1.hobby2[0] = \"搓澡\"\n fmt.Println(p1, *p1.hobby)\n fmt.Println(p2, *p1.hobby)\n"
        ]
    },
    "切片删除元素^": {
        "prefix": "*~append",
        "body": [
            "var arr = [...]int{11, 22, 33, 44, 55, 66}\n deleteIndex := 2\n \n result := append(arr[:deleteIndex], arr[deleteIndex+1:]...)\n fmt.Println(result) //[11 22 44 55 66 66]\n fmt.Println(arr)    //[11 22 44 55 66]\n"
        ]
    },
    "切片指定位置插入元素^": {
        "prefix": "*~append",
        "body": [
            "v1 := []int{11, 22, 33, 44, 55, 66}\n inserIndex := 3 //在索引3的位置插入99\n \n result := make([]int, 0, len(v1)+1)\n result = append(result, v1[:inserIndex]...)\n result = append(result, 99)\n result = append(result, v1[inserIndex:]...)\n fmt.Println(result) //[11 22 33 99 44 55 66]\n"
        ]
    },
    "用户输入fmt.Scanf^": {
        "prefix": "*~Scanf",
        "body": [
            "var name string\n var age int\n fmt.Print(\"请输入用户名：\")\n count, err := fmt.Scanf(\"我叫%s 今年%d 岁\", &name, &age) //cmd输入：我叫jch 今年18 岁\n fmt.Println(name, age)\nfmt.Println(count, err)\n\n\n\n//缺陷：无法获取空格后的内容\n//var message string\n //fmt.Print(\"请输入个人信息\")\n //fmt.Scanf(&message)\n //fmt.Println(message)\n"
        ]
    },
    "GO计算器^": {
        "prefix": "*~iota",
        "body": [
            "//iota计数器\n //示例一\n const (\n v1 = iota\n v2\n v3\n v4\n v5\n )\n fmt.Println(v1, v2, v3, v4, v5)\n //示例二\n const (\n v6 = iota + 1\n v7\n v8\n )\n fmt.Println(v6, v7, v8)\n //示例三\n const (\n v9 = iota + 1\n _\n v10\n v11\n )\n fmt.Println(v9, v10, v11)\n"
        ]
    },
    "获取结构体中字段名和标签^": {
        "prefix": "*~reflect",
        "body": [
            "type Person struct {\n name string \"姓名\"\n age  int32  \"年龄\"\n blog string \"博客\"\n }\n p1 := Person{name: \"武沛齐\", age: 18, blog: \"https://www.pythonav.com\"}\n p1Type := reflect.TypeOf(p1)\n //------------------写法一-----------------------------\n //写法一\n filed1 := p1Type.Field(0)\n fmt.Println(filed1.Tag)  //姓名\n fmt.Println(filed1.Name) //name\n \n //------------------写法二-----------------------------\n //写法二\n filed2, _ := p1Type.FieldByName(\"blog\") //是否存在字段\n fmt.Println(filed2.Tag)                 //博客\n \n //------------------写法三----------------------------\n //循环获取\n fieldNum := p1Type.NumField() //总共有多少个字段 3\n //循环 0 1 2\n for index := 0; index < fieldNum; index++ {\n field := p1Type.Field(index)\n fmt.Println(field.Name, field.Tag) //name 姓名 age 年龄 blog 博客\n \n }\n"
        ]
    },
    "获取当前计算机cpu个数^": {
        "prefix": "*~cpu",
        "body": [
            "//获取当前计算机的cpu个数\n cpuNum := runtime.NumCPU()\n fmt.Println(\"cpuNum=\", cpuNum)\n \n //设置运行cpu个数\n runtime.GOMAXPROCS(cpuNum - 1) //总cpu-1\n fmt.Println(\"ok\")\n"
        ]
    },
    "关闭管道^": {
        "prefix": "*~close",
        "body": [
            "var ch1 = make(chan int, 10)\n for i := 1; i <= 10; i++ {\n ch1 <- i\n }\n //不关闭报错fatal error: all goroutines are asleep - deadlock!\n close(ch1) //关闭管道\n \n //for range循环遍历管道的值，注意：管道没有key\n for v := range ch1 {\n fmt.Println(v)\n }\n //通过for 循环可以不关闭管道\n"
        ]
    },














    //------------------------------数据类型-------------------------------------------
    "整型": {
        "prefix": ":~type",
        "body": [
            "\t//整型(范围值)", "\t//有符号                         无符号", "\t//int8 (-128~127)               //uint8 (0~255)", "\t//int16 (-32768~32767)//uint16 (0~65535)", "\t//int32 (-21亿~21亿)//uint32 (0~42亿)", "\t//int64 (-19位数~19位数)        //uint64 (20位数)", "", "\t//注意：int8只能和int8相加或比较，int16 int32同理，不相同必须强制转换后在相加或比较", "\t//提示：提示：高位不能转向地位", "\t//示例1：int8 转int16", "\tvar v1 int8 = 10", "\tvar v2 int16 = 18", "\tv3 := int16(v1) + v2", "\tfmt.Println(v3)", "", "\t// //错误语法", "\t// var v1 int8 = 10", "\t// var v2 int16 = 18", "\t// v3 := v1 + v2", "\t// fmt.Println(v3)", "\t//错误语法", "\t// var v1 int8 = 10", "\t// var v2 int16 = 10", "\t// if v1 == v2 {", "\t// fmt.Println(1)", "\t//}", "", "\t//整型转字符串", "\t//提示：不支持int8,16,32转字符串，如果非要将int8,16,32转字符串，可以先将int8,16,32转int,在转字符串", "\tv4 := 19 //因式分解后 var v4 int = 19", "\tresult := strconv.Itoa(v4)", "\tfmt.Println(result, reflect.TypeOf(result))", "", "\t//int8,int16,int32转字符串", "\tvar v5 int8 = 12", "\tresult2 := strconv.Itoa(int(v5))", "\tfmt.Println(result2, reflect.TypeOf(result2))", "", "\t//字符串转整型", "\tv6 := \"666\"", "\t//err转换成功:<nil> err转换失败：错误信息", "\tresult6, err := strconv.Atoi(v6)", "\tif err == nil {", "\t\tfmt.Println(\"转换成功\", result6, reflect.TypeOf(result6))", "\t} else {", "\t\tfmt.Println(\"转换失败\")", "\t}", "", "\tv7 := 58", "\t//整型转二进制", "\tresult7 := strconv.FormatInt(int64(v7), 2)", "\t//整型转十六进制", "\tresult8 := strconv.FormatInt(int64(v7), 16)", "\tfmt.Println(result7, result8, reflect.TypeOf(result8))", "", "\t//二进制转整型", "\t//我们12345678910就是十进制", "\tdata := \"101101001\"", "\tresult9, err := strconv.ParseInt(data, 2, 16)", "\tfmt.Println(result9, err)", "", "\tfmt.Println(math.Abs(-19))                //绝对值", "\tfmt.Println(math.Floor(3.14))             //向下取整", "\tfmt.Println(math.Ceil(3.14))              //向上取整", "\tfmt.Println(math.Round(3.5478))           //四舍五入", "\tfmt.Println(math.Round(3.3478*100) / 100) //保留小数点后两位", "\tfmt.Println(math.Mod(11, 3))              //取余数，同11%3", "\tfmt.Println(math.Pow(2, 5))               //计算次方，如：2的5次方", "\tfmt.Println(math.Pow10(2))                //计算次方，如：2的10次方", "\tfmt.Println(math.Max(1, 2))               //最大值", "\tfmt.Println(math.Min(1, 2))               //最小值"
        ]
    },
    "超大整型": {
        "prefix": ":~type",
        "body": [
            "//存储超大整型\n v1 := new(big.Int)\n // var v1 big.Int //指向一个地址 值为0\n //不建议使用v1.SetInt64() 原因不能超过19位\n //建议使用SetString()\n v1.SetString(\"4411341541831321535151351231\", 10)\n fmt.Println(v1)\n //SetString可以将二进制转十进制存储到内存中\n v1.SetString(\"0101000110\", 2)\n fmt.Println(v1)\n//超大整型Add加 Sub减 Mul乘\n n1 := new(big.Int)\n n1.SetString(\"48646546468464684684684648\", 10)\n n2 := new(big.Int)\n n2.SetString(\"48646546468464684684684648\", 10)\n result := new(big.Int)\n result.Add(n1, n2)\n fmt.Println(result)\n"
        ]
    },
    "指针类型": {
        "prefix": ":~type",
        "body": [
            "//*指针\n //推荐使用new(int)\n//指针是为了节省内存\n var v2 *int    //创建了一个地址，值为指向nil的地址\n v3 := new(int) //开辟两块内存，一块存储值，另一块存储值的地址； v3存储的是值的地址\n fmt.Println(v2, v3)\n\n\n var v4 int8 = 16\n fmt.Println(v4)\n //转指针类型\n fmt.Println(\"一\", &v4)\n \n\n\n//试题\n var v5 big.Int\n var v6 *int\n v7 := new(int)\n var v8 int\n fmt.Println(v5, v6, v7, v8)\n //以上那两个不是指针类型：v1 v2\n"
        ]
    },
    "浮点型": {
        "prefix": ":~type",
        "body": [
            "//浮点型\n //注意：浮点型加减乘除会丢失精度，解决办法使用第三方decimal包\n \n //丢失精度\n //注意因式分解默认是float64\n var v1 float32\n v1 = 3.14\n v2 := 99.9\n v3 := float64(v1) + v2\n fmt.Println(v3) //103.04000010490418\n //错误语法\n // var v4 float32\n // v4 = 3.14\n // v5 := 99.9\n // v6 := v4 + v5\n // fmt.Println(v4, v5, v6)\n //丢失精度\n v7 := 0.1\n v8 := 0.2\n result := v7 + v8\n fmt.Println(result) //0.30000000000000004\n"
        ]
    },
    "数组+": {
        "prefix": ":~type",
        "body": [
            "\n //数组\n //数组的元素可以被修改（长度和类型都不可以修改）\n//方式一：声明int类型数组\n //声明int类型数组内存初始化的值是0\n var numbers [3]int\n //赋值\n numbers[0] = 999\n numbers[1] = 666\n numbers[2] = 333\n fmt.Println(numbers)\n \n //方式二：声明+赋值\n var names = [2]string{\"武沛齐\", \"alex\"}\n fmt.Println(names)\n \n //方式三：声明+赋值+指定位置\n var ages = [4]int{0: 88, 1: 99, 3: 666}\n fmt.Println(ages)\n \n //方式四：省略个数\n var v1 = [...]string{\"jiang\", \"chen\", \"hua\"}\n var v2 = [...]int{5, 5}\n fmt.Println(v1, v2)\n"
        ]
    },
    "数组切片+": {
        "prefix": ":~type",
        "body": [
            "//数组切片\n nums := [3]int32{11, 22, 33}\n data := nums[0:2]\n fmt.Println(data) //[11 22]\n"
        ]
    },
    "数组嵌套+": {
        "prefix": ":~type",
        "body": [
            "\n //数组嵌套\n var nestData [2][3]int\n nestData[0] = [3]int{1, 2, 3}\n nestData[1][1] = 666\n fmt.Println(nestData)\n \n //简写数组嵌套\n nestData2 := [2][3]int{[3]int{11, 22, 33}, [3]int{44, 55, 66}}\n fmt.Println(nestData2)\n"
        ]
    },
    "切片 创建切片+": {
        "prefix": ":~type",
        "body": [
            "//创建切片一（不推荐）每次插入数据需要扩容\n var nums []int //存储原理 容量=0 长度=0 值=空\n \n //创建切片二（推荐使用）\n var data = []int{11, 22, 33} //存储原理 容量=3 长度=3 值=11 22 33\n //简写\n //data := make([]int, 2, 5)\n //创建切片三（推荐使用）\n var users = make([]int, 1, 3) //存储原理 容量=3 长度=3 值只有一个0\n fmt.Println(nums, data, users)\n//创建切片四 \nchunk := make([]byte, 1024) //创建1024个字节切片\nfmt.Println(chunk)"
        ]
    },
    "切片 自动扩容+": {
        "prefix": ":~type",
        "body": [
            "//自动扩容\n v3 := []int{11, 22, 33}\n fmt.Println(v3, len(v3), cap(v3))\n \n v4 := append(v3, 44)\n fmt.Println(v3, len(v3), cap(v3))\n fmt.Println(v4, len(v4), cap(v4)) // v4 扩容后存储地址和v3不是同一块地址\n \n //没有扩容\n v1 := make([]int, 1, 3)\n v2 := append(v1, 90)\n fmt.Print(v1, v2) //v1 和 v2 没有扩容情况下存储地址是同一块地址\n \n //证明是同一块地址\n v1[0] = 999\n fmt.Println(v1, v2)\n"
        ]
    },
    "切片 索引切片+": {
        "prefix": ":~type",
        "body": [
            "//索引\n v1 := []string{\"a\", \"b\", \"c\"}\n fmt.Println(v1[0], v1[1], v1[2])\n \n v2 := make([]int, 2, 5)\n v2[0] = 333\n fmt.Println(v2[0], v2[1])\n //fmt.Println(v2[2]) 错误语法\n \n //切片\n v3 := []int{11, 22, 33, 44, 55}\n v4 := v3[1:3] //1~<3的切片\n v5 := v3[1:]  //1~最大索引\n v6 := v3[:3]  //0~2的切片\n fmt.Println(v4, v5, v6)\n"
        ]
    },
    "切片嵌套+": {
        "prefix": ":~type",
        "body": [
            "\n v1 := []int{11, 22, 33, 99, 55, 66}\n \n //切片嵌套切片\n v2 := [][]int{[]int{11, 22, 33, 44}, []int{44, 55}}\n \n //切片嵌套数组\n v3 := [][2]int{[2]int{1, 2}, [2]int{4, 5}}\n \n fmt.Println(v1)\n fmt.Println(v2)\n fmt.Println(v3)\n \n v1[0] = 11111\n v2[0][2] = 222222\n v3[1][0] = 9999\n \n fmt.Println(v1)\n fmt.Println(v2)\n fmt.Println(v3)\n"
        ]
    },
    "map 声明+赋值+": {
        "prefix": ":~type",
        "body": [
            "//map声明+赋值(方式一和方式二最重要)\n //方式一（常用）\n // userInfo := map[string]string{}\n // fmt.Println(userInfo)\n userInfo := map[string]string{\"name\": \"武沛齐\", \"age\": \"18\"}\n fmt.Println(userInfo)\n fmt.Println(userInfo[\"name\"])\n //重新赋值\n userInfo[\"age\"] = \"24\"\n //添加元素\n userInfo[\"email\"] = \"1451411245@qq.com\"\n fmt.Println(userInfo)\n \n //方式二（常用）\n //data := make(map[int]int,10) //10表示10个存储位置\n data := make(map[int]int)\n data[100] = 99\n data[88] = 88\n fmt.Println(data)\n \n //方式三（不常用）\n //map只声明是无法给里面添加row[\"name\"] = 888值的，只能用于整体赋值\n var row map[int]int\n //row[\"name\"] = 888 报错\n //整体赋值\n row = data\n fmt.Println(row)\n \n //方式四（不常用）\n //用于整体赋值\n value := new(map[int]int)\n //value[\"k1\"] = 1报错\n data2 := make(map[int]int)\n data2[100] = 99\n data2[88] = 88\n \n value = &data2\n fmt.Println(value)\n \n //方式五（不常用）\n v1 := make(map[[2]int]float32)\n v1[[2]int{1, 1}] = 1.6\n v1[[2]int{1, 2}] = 3.4\n fmt.Println(v1)\n"
        ]
    },
    "map 长度和容量+": {
        "prefix": ":~type",
        "body": [
            "data := map[string]string{\"n1\": \"武沛齐\", \"n2\": \"alex\"}\n //map长度\n val := len(data)\n fmt.Println(val)\n //10表示10个容量\n info := make(map[string]string, 10)\n info[\"n1\"] = \"武沛齐\"\n info[\"n2\"] = \"alex\"\n //map长度\n v1 := len(info)\n fmt.Println(v1)\n //map无法计算容量，所以报错\n //v2 := cap(info) 报错\n"
        ]
    },
    "map 增删改查": {
        "prefix": ":~type",
        "body": [
            "\n //map增删改查\n \n data := map[string]string{\"n1\": \"武沛齐\", \"n2\": \"alex\"}\n //添加\n data[\"n3\"] = \"eric\"\n \n //修改\n data[\"n3\"] = \"alex\"\n \n //删除\n delete(data, \"n2\")\n \n //查\n fmt.Println(data[\"n1\"])\n //查所以\n for key, val := range data {\n fmt.Println(key, val)\n }\n"
        ]
    },
    "map 嵌套+": {
        "prefix": ":~type",
        "body": [
            "\tv1 := make(map[string]int)", "\tv2 := make(map[string]string)", "\t// v3 := make(map[string]...) //报错  未知原因", "\tv4 := make(map[string][2]int)", "\tv5 := make(map[string][]int)", "\tv6 := make(map[string]map[int]int)", "\tv7 := make(map[string][2]map[string]string)", "\tv7[\"n1\"] = [2]map[string]string{map[string]string{\"name\": \"武沛齐\", \"age\": \"18\"}, map[string]string{\"name\": \"alex\", \"age\": \"78\"}}", "\tv7[\"n2\"] = [2]map[string]string{map[string]string{\"name\": \"eric\", \"age\": \"18\"}, map[string]string{\"name\": \"seven\", \"age\": \"78\"}}", "", "\t//伪代码 搞不懂什么意思，不管他", "\t// v7 = {", "\t//n1:[", "\t// {\"name\":\"武沛齐\",\"age\": \"18\"},", "\t// {\"name\":\"alex\",\"age\":\"78\"}", "\t// ],", "\t// n2:[", "\t// {\"name\":\"eric\",\"age\":\"18\"},", "\t// {\"name\":\"seven\",\"age\":\"78\"}", "\t// ]", "\t// }", "", "\tfmt.Println(v1, v2, v4, v5, v6, v7)", "", "\t//前提：键不可重复 并且 键必须可哈希", "\tv8 := make(map[int]int)", "\tv9 := make(map[string]int)", "\tv10 := make(map[float32]int)", "\tv11 := make(map[bool]int)", "\tv12 := make(map[[2]int]int)", "\t// v13 := make(map[[]int]int)       //错误，不可哈希", "\t// v14 := make(map[map[int]int]int) //错误，不可哈希", "\t//v15 := make(map[[2][]int]int)             //报错", "\t//v16 := make(map[[2]map[string]string]int) //报错", "\tfmt.Println(v8, v9, v10, v11, v12)"
        ]
    },
    "map 赋值^": {
        "prefix": ":~type",
        "body": [
            "v1 := map[string]string{\"n1\": \"武沛齐\", \"n2\": \"alex\"}\n v2 := v1\n \n v1[\"n1\"] = \"wupeiqi\"\n fmt.Println(v1) //map[n1:wupeiqi n2:alex]\n fmt.Println(v2) //map[n1:wupeiqi n2:alex]\n"
        ]
    },
    "指针的指针^": {
        "prefix": ":~type",
        "body": [
            "name := \"武沛齐\"\n var p1 *string = &name\n var p2 **string = &p1\n var p3 ***string = &p2\n \n println(name, &name)\n println(p1, &p1)\n println(p2, &p2)\n println(p3, &p3)\n \n //示例\n linkname := \"武沛齐\"\n \n //声明一个指针类型的变量n1,内部存储linkname的内存地址\n var n1 *string = &linkname\n \n *n1 = \"张三\" //将name的内存中的值由 武沛齐 改为 张三\n \n //声明一个指针的指针类型变量n2,内部存储指针n1的内存地址\n var n2 **string = &n1\n **n2 = \"啦啦啦\" //将name的内存中的值由 张三 改为 啦啦啦\n \n var n3 ***string = &n2\n ***n3 = \"我靠\" //将name的内存中的值由 啦啦啦 改为 我靠\n \n fmt.Println(n1, n2, n3)\n fmt.Println(*n1, *n2, *n3)\n"
        ]
    },
    "结构体定义并初始化+": {
        "prefix": ":~type",
        "body": [
            "//结构体定义初始化\n //------------------------结构体定义方式一-------------------------\n //初始化写法一\ntype Person struct {\n name  string\n age   int\n hobby []string\n }\n\n var p1 = Person{\"武沛齐\", 19, []string{\"篮球\", \"足球\"}}\n fmt.Println(p1.name, p1.age, p1.hobby)\n \n //初始化写法二 关键字\n var p2 = Person{name: \"武沛齐\", age: 19, hobby: []string{\"篮球\", \"足球\"}}\n fmt.Println(p2.name, p2.age, p2.hobby)\n \n //初始化写法三 先声明再赋值\n var p3 Person\n p3.name = \"武沛齐\"\n p3.age = 18\n p3.hobby = []string{\"篮球\", \"足球\"}\n fmt.Println(p3.name, p3.age, p3.hobby)\n \n //------------------------结构体定义方式二-------------------------\n //结构体定义方式二\n //简写\n type Address struct {\n city, state string\n }\n //初始化同上\n \n //------------------------结构体定义方式三-------------------------\n //嵌套\n type Money struct {\n city, state string\n }\n type Money2 struct {\n name string\n age  int\n //moneymoney字段， Money Money\n money Money\n }\n //初始化写法一\n var m1 = Money2{\"武沛齐\", 19, Money{\"北京\", \"中国\"}}\n fmt.Println(m1.name, m1.age, m1.money, m1.money.city)\n //初始化写法二 关键字\n var m2 = Money2{name: \"武沛齐\", age: 19, money: Money{city: \"北京\", state: \"中国\"}}\n fmt.Println(m2.name, m2.age, m2.money, m2.money.city)\n //初始化写法三 先声明再赋值\n var m3 Money2\n m3.name = \"武沛齐\"\n m3.age = 50\n m3.money = Money{city: \"北京\", state: \"中国\"}\n fmt.Println(m3.name, m3.age, m3.money, m3.money.city)\n"
        ]
    },
    "结构体指针+": {
        "prefix": ":~type",
        "body": [
            "//结构体指针\n type Person struct {\n name string \"姓名\"\n age  int \"年龄\"\n }\n \n //初始化结构体指针\n p2 := &Person{\"武沛齐\", 18} //相当于var p2 *Person = &Person{\"武沛齐\", 18}\n \n fmt.Println(p2) //&{武沛齐 18} 通过指针找到对应的值\n \n var p3 *Person = new(Person)\n p3.name = \"武沛齐\"\n p3.age = 18\n fmt.Println(p3.name, p3.age)\n//结构体指针存储流程：结构体指针开辟两块内存，一块存值的地址，一块存值，而初始化结构体是开辟一块内存存储值"
        ]
    },
    "结构体赋值 结构体指针赋值+": {
        "prefix": ":~type",
        "body": [
            "//----------------结构体赋值---------------------\n //结构体赋值是拷贝一份\n type Person struct {\n name string\n age  int\n }\n p1 := Person{name: \"武沛齐\", age: 18}\n p2 := p1 //内部将p1重新拷贝一份\n \n fmt.Println(p1) //{武沛齐 18}\n fmt.Println(p2) //{武沛齐 18}\n \n p1.name = \"alex\"\n fmt.Println(p1) // {alex 19}\n fmt.Println(p2) // {武沛齐 19}\n //----------------结构体指针赋值---------------------\n type Person2 struct {\n name string\n age  int\n }\n v1 := &Person2{\"武沛齐\", 18}\n v2 := v1        //拷贝赋值\n fmt.Println(v1) //&{武沛齐 18}\n fmt.Println(v2) //&{武沛齐 18}\n v1.name = \"猛男\"\n fmt.Println(v1) //&{猛男 18}\n fmt.Println(v2) //&{猛男 18}\n"
        ]
    },
    "channel管道基础": {
        "prefix": ":~type",
        "body": [
            "//1.创建channel\n ch := make(chan int, 3)\n //2.给管道里面存储数据\n ch <- 10\n ch <- 20\n ch <- 32\n //3.获取管道里面的数据\n a := <-ch //10\n <-ch      //从管道里取数据 //20\n c := <-ch //32\n fmt.Println(a)\n fmt.Println(c)\n ch <- 58\n //4.打印管道的长度和容量\n fmt.Printf(\"值：%v 容量：%v 长度%v\\n\", ch, cap(ch), len(ch)) //值：0xc000110080 容量：3 长度1\n \n //5.管道的类型（引用数据类型）\n ch1 := make(chan int, 4)\n ch1 <- 34\n ch1 <- 54\n ch1 <- 64\n \n ch2 := ch1\n ch2 <- 25\n <-ch1\n <-ch1\n <-ch1\n d := <-ch1\n fmt.Println(d)\n//6.管道阻塞\n ch6 := make(chan int, 1)\n ch6 <- 34\n //ch6 <- 54 //死锁\n \n ch7 := make(chan string, 2)\n ch7 <- \"数据1\"\n ch7 <- \"数据2\"\n \n m1 := <-ch7\n m2 := <-ch7\n //m3 := <-ch7 //报错\n fmt.Println(m1, m2)\nch8 := make(chan int, 1)\n ch8 <- 34\n <-ch8\n ch8 <- 67\n <-ch8\n ch8 <- 78\n m4 := <-ch8\n fmt.Println(m4)\n"
        ]
    },
    "只读和只写管道^": {
        "prefix": ":~type",
        "body": [
            "package main\n \n import (\n \"fmt\"\n \"sync\"\n )\n \n var wg sync.WaitGroup\n \n //写数据\n func fn1(ch chan<- int) {\n for i := 1; i < 10; i++ {\n ch <- i\n fmt.Printf(\"【写入】数据%v成功\n\", i)\n }\n \n close(ch)\n wg.Done()\n }\n \n func fn2(ch <-chan int) {\n for v := range ch {\n fmt.Printf(\"【读取】数据%v成功\n  %v\n\", v, v)\n }\n wg.Done()\n \n }\n \n func main() {\n var ch = make(chan int, 10)\n wg.Add(1)\n go fn1(ch)\n wg.Add(1)\n go fn2(ch)\n wg.Wait()\n }\n"
        ]
    },
    "select多路复用同时获取多个管道数据": {
        "prefix": ":~type",
        "body": [
            "package main\n \n import \"fmt\"\n \n func main() {\n \n //在某些场景下我们需要同时从多个管道接收数据，这时候就可以用到golang中给我们select\n \n //1.定义一个管道 10个数据int\n intChan := make(chan int, 10)\n for i := 0; i < 10; i++ {\n intChan <- i\n }\n //2.定义一个管 5个数据string\n stringChan := make(chan string, 5)\n for i := 0; i < 5; i++ {\n stringChan <- \"hello\" + fmt.Sprintf(\"%d\", i)\n }\n //使用select多路复用不需要关闭channel\n for {\n select {\n case v := <-intChan:\n fmt.Printf(\"从 intChan 读取的数据%d\\n\", v)\n case v := <-stringChan:\n fmt.Printf(\"从 stringChan 读取的数据%d\\n\", v)\n default:\n fmt.Printf(\"数据获取完毕\")\n return //注意退出\n }\n }\n }\n"
        ]
    },









    //------------------------------func-------------------------------------------
    "func函数做参数": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n func add100(arg int) (int, bool) {\n return arg + 100, true\n }\n \n type f1 func(arg int) (int, bool)\n \n //复杂写法\n // func proxy(data int, exec func(int) (int, bool)) int {\n //简写\n func proxy(data int, exec f1) int {\n data, flag := exec(data)\n if flag {\n return data\n } else {\n return 9999\n }\n \n }\n func main() {\n result := proxy(123, add100)\n fmt.Println(result)\n }\n"
        ]
    },
    "返回函数": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n func exec(num1 int, num2 int) string {\n fmt.Println(\"执行函数了\")\n return \"成功\"\n }\n \n // type f1 func(int, int) string 简写\n func getFunction() func(int, int) string {\n return exec\n }\n func main() {\n function := getFunction()\n result := function(111, 222)\n fmt.Println(result)\n }\n"
        ]
    },

    "...变长参数": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n //...变长参数只能放在最后且只能有一个\n func do(num ...int) int {\n //num 是一个切片类型\n sum := 0\n for _, value := range num {\n sum += value\n }\n return sum\n }\n \n func main() {\n res1 := do(1, 2, 34, 4)\n res2 := do(1, 2)\n fmt.Println(res1, res2)\n }\n"
        ]
    },
    "多个返回值^": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n func add100(arg int) (int, bool, int) {\n return arg + 100, true, 888\n }\n func main() {\n v1, v2, v3 := add100(555)\n fmt.Println(v1, v2, v3)\n }\n"
        ]
    },
    "匿名函数": {
        "prefix": ":~func",
        "body": [
            "package main", "", "import \"fmt\"","// func F1(n1 int, n2 int) func(int) string {", "// return func(n1 int) string {", "// fmt.Println(\"匿名函数\")", "// return \"匿名\"", "// }", "// }", "func main() {", "\t//匿名函数", "\tv1 := func(n1 int, n2 int) int {", "\t\treturn n1 + n2", "\t}", "\tdata := v1(11, 22)", "\tfmt.Println(data)", "\t//匿名函数", "\tvalue := func(n1 int, n2 int) int {", "\t\treturn n1 + n2", "\t}(33, 44)", "\tfmt.Println(value)", "\t//匿名函数(存在bug)", "\t// f1 := F1(1, 2)", "\t// fmt.Println(f1)", "}"
        ]
    },
    "闭包^": {
        "prefix": ":~func",
        "body": [
            "\t//存储着5个函数", "\tvar functionList []func()", "\tfor i := 0; i < 5; i++ {", "\t\t//闭包", "\t\t// function := func() {", "\t\t// fmt.Println(i) //5", "\t\t// }", "\t\t//解决闭包", "\t\tfunction := func(arg int) func() {", "\t\t\treturn func() {", "\t\t\t\t// fmt.Println(i) 5", "\t\t\t\tfmt.Println(arg)", "\t\t\t}", "\t\t}(i)", "\t\tfunctionList = append(functionList, function)", "\t}", "\t//运行函数", "\tfunctionList[0]()", "\tfunctionList[1]()", "\tfunctionList[2]()"
        ]
    },
    "淫迟执行": {
        "prefix": ":~func",
        "body": [
            "func index(num int) {\n fmt.Println(num)\n }\n func do() int {\n fmt.Println(\"风吹\")\n //多个defer挺迟执行,顺序是倒序执行\n //淫迟执行\n defer fmt.Println(\"函数执行完毕了\")\n defer index(1)\n fmt.Println(\"屁屁凉\")\n return 666\n }\n func main() {\n ret := do()\n fmt.Println(ret)\n }\n"
        ]
    },
    "自动执行函数^": {
        "prefix": ":~func",
        "body": [
            "//自动执行函数\n res := func(arg int) int {\n return arg + 100\n }(123)\n fmt.Println(res)\n"
        ]
    },
    "私有方法^": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n //声明类型\n//声明类型也可以是一个结构体\n type MyInt int\n \n //-------------私有方法也叫类型方法-----------------\n // func (i *MyInt) DoSomething(a1 int, a2 int) int {\n func (_ *MyInt) DoSomething(a1 int, a2 int) int {\n // return a1 + a2 + int(*i)\n return a1 + a2\n }\n func main() {\n var v1 MyInt = 1\n result := v1.DoSomething(1, 2)\n //DoSomething(1, 2)  报错\n fmt.Println(result)\n }\n"
        ]
    },
    "方法继承+": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n type Base struct {\n name string\n }\n type Son struct {\n Base //匿名的方式，如果改成 base Base则无法继承Base的方法。\n age  int\n }\n \n //Base结构体的方法\n func (b *Base) m1() int {\n return 666\n }\n \n //Son结构体的方法\n func (s *Son) m2() int {\n return 999\n }\n func main() {\n son := Son{age: 18, Base: Base{name: \"武沛齐\"}}\n \n res1 := son.m1()\n res2 := son.m2()\n fmt.Println(res1, res2)\n }\n"
        ]
    },
    "空接口传参任意类型++": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n type Person struct {\n name string\n age  int\n }\n type Role struct {\n title string\n count int\n }\n \n func something(arg interface{}) {\n //多个类型转换，将arg接口对象转换为。（断言·）\n switch tp := arg.(type) {\n case Person:\n fmt.Println(tp.name)\n case Role:\n fmt.Println(tp.title)\n case string:\n fmt.Println(tp)\n default:\n fmt.Println(tp)\n }\n \n }\n func main() {\n something(\"武沛齐\")\n something(666)\n something(4.15)\n something(Person{name: \"wupeiqi\", age: 18})\n something(Role{title: \"wupeiqi\", count: 18})\n }\n"
        ]
    },
    "非空接口约束func": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n //定义非空接口\n type IBase interface {\n f1() int\n }\n \n //定义结构体Person\n type Person struct {\n name string\n }\n \n //为结构体Person定义方法\n func (p Person) f1() int {\n return 123\n }\n \n //定义结构体user\n type User struct {\n name string\n }\n \n //为结构体User定义方法\n func (p User) f1() int {\n return 666\n }\n \n //基于接口的参数，可以实现传入多种类型（多态），也同时具有约束对象必须实现接口方法的功能\n func DoSomething(base IBase) {\n result := base.f1()\n fmt.Println(result)\n }\n \n func main() {\n per := Person{name: \"武沛齐\"}\n user := User{name: \"wupeiqi\"}\n \n DoSomething(per)\n DoSomething(user)\n \n }\n"
        ]
    },
    "空接口类型断言转换+": {
        "prefix": ":~func",
        "body": [
            "package main\n \n import \"fmt\"\n \n //空接口接收参数是空接口类型，运算需要使用类型断言转换\n func reflectValue(x interface{}) {\n b, _ := x.(float64) //可以int\n var num = 10.3 + b\n fmt.Println(num)\n }\n \n func main() {\n var a = 13.3\n reflectValue(a)\n }\n"
        ]
    },




















    //------------------------------块函数-------------------------------------------
    "获取文件扩展名": {
        "prefix": "~file",
        "body": [
            "//获取文件扩展名\n ext := path.Ext(\"xxx/xxx/xxx/xx.txt\")\n fmt.Println(ext)\n"
        ]
    },
    "路径拼接(推荐)": {
        "prefix": "~file",
        "body": [
            "//路径拼接(推荐)\n filePath := filepath.Join(\"v1\", \"v2\", \"v3\", \"v6.exe\")\n fmt.Println(filePath)\n"
        ]
    },
    "遍历目录文件 （多级）": {
        "prefix": "~file",
        "body": [
            "//遍历目录文件 （多级）\n filepath.Walk(\"/goproject/src/hello\", func(path string, info os.FileInfo, err error) error {\n if !info.IsDir() {\n fmt.Println(\"文件有：\", path)\n } else {\n fmt.Println(\"文件夹有：\", path)\n }\n return nil\n })\n"
        ],
        "description": "~file"
    },
    "遍历目录文件（一级）": {
        "prefix": "~file",
        "body": [
            "fileList, _ := ioutil.ReadDir(\"/goproject/src/hello\")\n for _, obj := range fileList {\n fmt.Println(obj.Name())\n }\n"
        ],
        "description": "~file"
    },
    "生成绝对路径": {
        "prefix": "~file",
        "body": [
            "//生成绝对路径\n absPath, _ := filepath.Abs(\"test\") //不是创建文件，而是拼接上绝对地址\n fmt.Println(absPath)\n"
        ],
        "description": "~file"
    },
    "判断文件或文件夹是否存在": {
        "prefix": "~file",
        "body": [
            "//判断文件或文件夹是否存在\n _, err := os.Stat(\"/goproject/src/day02/\")\n if err != nil {\n if os.IsNotExist(err) {\n fmt.Println(\"文件或文件夹不存在\")\n }\n } else {\n fmt.Println(\"文件或文件夹存在\")\n }\n"
        ]
    },
    "删除文件或单多目录": {
        "prefix": "~file",
        "body": [
            "//删除文件和文件夹\n //删除文件或空文件夹，文件夹下存在文件则报错\n if err := os.Remove(\"x2\"); err != nil {\n fmt.Println(\"删除失败\", err)\n } else {\n fmt.Println(\"删除成功\")\n }\n //删除文件或文件夹（同时删除子目录）\n if err := os.RemoveAll(\"t2\"); err != nil {\n fmt.Println(\"删除失败：\", err)\n } else {\n fmt.Println(\"删除成功\")\n }\n"
        ]
    },
    "创建单多级目录": {
        "prefix": "~file",
        "body": [
            "//创建单级目录\n // err := os.Mkdir(\"x2\", 0755)\n // fmt.Println(err)\n // if err != nil {\n \n // }\n //简写\n if err := os.Mkdir(\"x2\", 0755); err == nil {\n fmt.Println(\"文件夹x2创建成功\")\n } else {\n fmt.Println(err)\n }\n //创建多级目录，已存在则什么都不做\n // err2 := os.MkdirAll(\"t2/src/code/test\", 0755)\n // fmt.Println(err2)\n if err2 := os.MkdirAll(\"t2/src/code/test\", 0755); err2 != nil {\n fmt.Println(\"t2/src/code/test创建成功\")\n } else {\n fmt.Println(err2)\n }\n"
        ]
    },
    "字符串函数": {
        "prefix": "~str",
        "body": [
            "//是否以\"武开头\n name1 := \"武沛齐\"\n result1 := strings.HasPrefix(name1, \"武\")\n fmt.Println(result1) //true\n \n //是否以\"齐\"结尾\n name2 := \"武沛齐\"\n result2 := strings.HasSuffix(name2, \"齐\")\n fmt.Println(result2) //true\n \n //全部转大写\n name3 := \"jiangchenhua\"\n result3 := strings.ToUpper(name3)\n fmt.Println(result3) //JIANGCHENHUA\n \n //全部转小写\n name4 := \"JIANGCHENHUA\"\n result4 := strings.ToLower(name4)\n fmt.Println(result4) //jiangchenhua\n \n //去两边字符\n name5 := \"jiangchenhua\"\n result5 := strings.TrimRight(name5, \"hua\")\n result6 := strings.TrimLeft(name5, \"jiang\")\n fmt.Println(result5, result6) //jiangchen chenhua\n"
        ]
    },
    "*字符串拼接^": {
        "prefix": "~join^",
        "body": [
            "//字符串拼接", "\t//不建议", "\tmessage := \"我爱\" + \"北京天安门\"", "\tfmt.Println(message)", "", "\t//建议：效率高一些", "\tdataList := []string{\"我爱\", \"北京天安门\"}", "\tresult := strings.Join(dataList, \"\")", "\t// result := strings.Join(dataList, \"-\") //我爱-北京天安门", "\tfmt.Println(result)", "", "\t//效率更高一些（go 1.10之前）", "\tvar buffer bytes.Buffer", "\tbuffer.WriteString(\"你想\")", "\tbuffer.WriteString(\"我干\")", "\tbuffer.WriteString(\"他\")", "\tdata := buffer.String()", "\tfmt.Println(data)", "", "\t//建议推荐使用：效率更更更高一些（go 1.10之后）", "\t//效率最高的字符串拼接", "\tvar builder strings.Builder", "\tbuilder.WriteString(\"哈哈哈\")", "\tbuilder.WriteString(\"去你的吧\")", "\tvalue := builder.String()", "\tfmt.Println(value)"
        ]
    },
    "*数字运算": {
        "prefix": "~math",
        "body": [
            "fmt.Println(math.Abs(-19))                //绝对值\n fmt.Println(math.Floor(3.14))             //向下取整\n fmt.Println(math.Ceil(3.14))              //向上取整\n fmt.Println(math.Round(3.5478))           //四舍五入\n fmt.Println(math.Round(3.3478*100) / 100) //保留小数点后两位\n fmt.Println(math.Mod(11, 3))              //取余数，同11%3\n fmt.Println(math.Pow(2, 5))               //计算次方，如：2的5次方\n fmt.Println(math.Pow10(2))                //计算次方，如：2的10次方\n fmt.Println(math.Max(1, 2))               //最大值\n fmt.Println(math.Min(1, 2))               //最小值\n \n"
        ]
    },
    "整型转int[int,8,16,32]()": {
        "prefix": "~type",
        "body": [
            "//注意：int8只能和int8相加或比较，int16 int32同理，不相同必须强制转换后在相加或比较\n//提示：高位不能转向地位\n//var v4 int16= 130\n//v5 := int8(v4)\n//fmt.Println(v5)\n var v1 int = 10\n var v2 int16 = 18\n v3 := int16(v1) + v2\n fmt.Println(v3)\n // //错误语法\n // var v1 int8 = 10\n // var v2 int16 = 18\n // v3 := v1 + v2\n // fmt.Println(v3)\n //错误语法\n // var v1 int8 = 10\n // var v2 int16 = 10\n // if v1 == v2 {\n // fmt.Println(1)\n//}\n"
        ]
    },
    "整型转字符串": {
        "prefix": "~type",
        "body": [
            "//整型转字符串\n //提示：不支持int8,16,32转字符串，如果非要将int8,16,32转字符串，可以先将int8,16,32转int,在转字符串\n v4 := 19 //因式分解后 var v4 int = 19\n result := strconv.Itoa(v4)\n fmt.Println(result, reflect.TypeOf(result))\n \n //int8,int16,int32转字符串\n var v5 int8 = 12\n result2 := strconv.Itoa(int(v5))\n fmt.Println(result2, reflect.TypeOf(result2))\n"
        ]
    },
    "字符串转整型": {
        "prefix": "~type",
        "body": [
            "//字符串转整型\n v6 := \"666\"\n //err转换成功:<nil> err转换失败：错误信息\n result6, err := strconv.Atoi(v6)\n if err == nil {\n fmt.Println(\"转换成功\", result6, reflect.TypeOf(result6))\n } else {\n fmt.Println(\"转换失败\")\n }\n"
        ]
    },
    "字符串转布尔类型": {
        "prefix": "~type",
        "body": [
            "//字符串转换布尔类型\n //true：\"1\", \"t\", \"T\", \"true\", \"TRUE\", \"True\"\n //false：\"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\"\n result, err := strconv.ParseBool(\"t\")\n fmt.Println(result, err)\n\n //布尔转字符串\n v1 := strconv.FormatBool(false)\n fmt.Println(v1, reflect.TypeOf(v1))\n"
        ]
    },
    "字符串转换字节集合+": {
        "prefix": "~type",
        "body": [
            "//字符串转为一个 \"字节集合\"\n //字符串可以是中文 数字 符合等\n //字节集合是十进制的集合，进制之间可以互相转换\n name := \"蒋郴华\"\n byteSet := []byte(name)\n fmt.Println(byteSet) //[232 146 139 233 131 180 229 141 142]\n"
        ]
    },
    "字节集合转换字符串+": {
        "prefix": "~type",
        "body": [
            "//字节集合转字符串\n byteList := []byte{232, 146, 139, 233, 131, 180, 229, 141, 142}\n targetString := string(byteList)\n fmt.Println(targetString) //蒋郴华\n"
        ]
    },
    "字符串转rune集合+": {
        "prefix": "~type",
        "body": [
            "//字符串转rune的集合\n //方法一(推荐)\n var name string = \"武沛齐\"\n tempSet := []rune(name)\n fmt.Println(tempSet) //[33931 37108 21326]\n \n //方法二\n //for range循环获取所以字节\n for index, item := range name {\n fmt.Println(index, item, string(item))\n }\n"
        ]
    },
    "rune集合转字符串+": {
        "prefix": "~type",
        "body": [
            "//rune的集合转字符串\n runes := []rune{33931, 37108, 21326}\n // fmt.Println(strconv.FormatInt(int64(runes[0]), 16))\n // fmt.Println(strconv.FormatInt(int64(runes[1]), 16))\n // fmt.Println(strconv.FormatInt(int64(runes[2]), 16))\n fmt.Println(string(runes))\n"
        ]
    },
    "float32转float64^": {
        "prefix": "~type",
        "body": [
            "//丢失精度，解决办法使用第三方decimal包\n //注意因式分解默认是float64\n var v1 float32\n v1 = 3.14\n v2 := 99.9\n v3 := float64(v1) + v2\n fmt.Println(v3) //103.04000010490418\n"
        ]
    },
    "整型转二进制^": {
        "prefix": "~type",
        "body": [
            "v7 := 58\n //整型转二进制\n result7 := strconv.FormatInt(int64(v7), 2)\n //整型转十六进制\n result8 := strconv.FormatInt(int64(v7), 16)\n fmt.Println(result7, result8, reflect.TypeOf(result8))\n"
        ]
    },
    "二进制转整型^": {
        "prefix": "~type",
        "body": [
            "//二进制转整型\n //我们12345678910就是十进制\n data := \"101101001\"\n result9, err := strconv.ParseInt(data, 2, 16)\n fmt.Println(result9, err)\n"
        ]
    },
    "十进制转字符串^": {
        "prefix": "~type",
        "body": [
            "//十进制转字符串\n v1 := string(65)\n fmt.Println(v1) //A\n \n v2 := string(23646)\n fmt.Println(v2) //属\n"
        ]
    },
    "字符串转十进制数字^": {
        "prefix": "~type",
        "body": [
            "//字符串转数字\n v3, size := utf8.DecodeRuneInString(\"A\")\n fmt.Println(v3, size) //65 1\n"
        ]
    },
    "转指针类型": {
        "prefix": "~type",
        "body": [
            "//转指针类型\n var v4 int8 = 16\n fmt.Println(v4)\n fmt.Println(\"一\", &v4)\n"
        ]
    },
    "时间处理函数^": {
        "prefix": "~time",
        "body": [
            "\t//1.获取当前本地时间", "\tt1 := time.Now()", "\tfmt.Println(\"当前本地时间（Time类型）:\", t1)", "", "\t//2.获取当前UTC时间 t2.Local()", "\tt2 := time.Now().UTC()", "\tfmt.Println(\"当前UTC时间 （Time类型）:\", t2)", "", "\t//3.创建一个时间，字符串类型->Time类型", "\tt3, _ := time.Parse(\"2006-01-02\", \"2018-11-11\")", "\tfmt.Println(\"根据字符串转换为时间（Time类型）:\", t3)", "", "\t//4.创建一个时间", "\tt4 := time.Date(2019, 11, 11, 11, 11, 11, 11, time.Local)", "\tfmt.Println(\"根据字符串转换为时间(Time类型)：\", t4)", "\tt5 := time.Date(2019, 11, 11, 11, 11, 11, 11, time.UTC)", "\tfmt.Println(\"根据字符串转换为时间（Time类型）：\", t5)", "", "\t//5.时间格式化，Time类型->字符串类型", "\t//Mon Jan 2 15:04:05 -0700 MST 2006", "\tfmt.Println(\"格式化之后的时间为（string类型）：\", t1.Format(\"2006-01-02 15:04:05.000000 -0700 MST\"))", "\tfmt.Println(\"格式化之后的时间为（string类型）：\", t2.Format(\"2006-01-02 15:04:05.000000 -0700 MST\"))", "\tfmt.Println(\"格式化之后的时间为（string类型）：\", t1.Format(\"2006-01-02 15:04:05\"))", "\tfmt.Println(\"格式化之后的时间为（string类型）：\", t1.Format(\"2006-01-02\"))", "", "\t//6.时间增加", "\tt6 := t1.Add(time.Hour * 1)", "\tfmt.Println(\"当前时间+1小时（Time类型）：\", t6)", "", "\t//7.时间减小", "\tt7 := t1.Add(-time.Hour * 1)", "\tfmt.Println(\"当前时间-1分钟（Time类型）：\", t7)", "", "\t//8.时间间隔", "\tt8 := t1.Sub(t4)", "\tfmt.Println(\"时间间隔为（Duration类型）：\", t8)", "\tfmt.Println(\"时间间隔小时：\", t8.Hours())", "\tfmt.Println(\"时间间隔为分钟：\", t8.Minutes())", "\tfmt.Println(\"时间间隔为秒：\", t8.Seconds())"
        ]
    },
















































    //------------------------------判断-------------------------------------------
    "if": {
        "prefix": "~if",
        "body": [
            "//示例一\n if true {\n fmt.Println(1)\n } else {\n fmt.Println(0)\n }\n //示例二 == > < >= <= != %\n if 2%2 == 0 {\n fmt.Println(1)\n } else {\n fmt.Println(0)\n }\n //示例三\n flag := false\n if flag {\n fmt.Println(1)\n } else {\n fmt.Println(0)\n }\n //示例四  &&  ||\n if 1 == 1 && 2 == 2 {\n fmt.Println(1)\n } else {\n fmt.Println(0)\n }\n//示例五 表达式\nif(1 == 1 && 2 == 3)||(4 == 4){\nfmt.Println(1)\n}else{\nfmt.Println(0)\n}"
        ]
    },
    "else if ": {
        "prefix": "~else if",
        "body": [
            "//示例一\nlength := 2\n if length == 1 {\n fmt.Println(1)\n } else if length == 2 {\n fmt.Println(2)\n } else {\n fmt.Println(3)\n }\n//示例二\n fmt.Println(\"欢迎致电10086，1.话费相关；2.业务办理；3.人工服务。\")\n \n var number int\n fmt.Scanln(&number)\n \n if number == 1 {\n fmt.Println(\"话费服务：1.交话费；2.查询。\")\n var n1 int\n fmt.Scanln(&n1)\n if n1 == 1 {\n fmt.Println(\"交话费啦\")\n } else if n1 == 2 {\n fmt.Println(\"查询话费\")\n } else {\n fmt.Println(\"输入错误\")\n }\n \n } else if number == 2 {\n fmt.Println(\"业务办理\")\n } else if number == 3 {\n fmt.Println(\"人工办理\")\n } else {\n fmt.Println(\"输入错误\")\n }\n //建议：条件的嵌套不要太多\n"
        ]
    },
    "switch": {
        "prefix": "~switch",
        "body": [
            "//注意：数据类型需要一致\n //示例一\n switch 1 + 1 {\n case 1:\n fmt.Println(1)\n case 2:\n fmt.Println(2)\n default:\n fmt.Println(0)\n }\n//示例二\n age := 2\n switch age {\n case 1:\n fmt.Println(1)\n case 2:\n fmt.Println(2)\n default:\n fmt.Println(0)\n }\n"
        ]
    },
    "goto": {
        "prefix": "~goto",
        "body": [
            "var name string\n fmt.Print(\"请输入姓名：\")\n fmt.Scanln(&name)\n if name == \"武武\" {\n goto VIP\n } else if name == \"华华\" {\n goto SVIP\n }\n fmt.Println(\"预约...\")\n VIP:\n fmt.Println(\"等待...\")\n SVIP:\n fmt.Println(\"进入...\")\n"
        ]
    },
    //------------------------------循环-------------------------------------------
    "for循环 打标签循环": {
        "prefix": "~for",
        "body": [
            "//示例1：死循环\n for {\n fmt.Println(1)\n time.Sleep(time.Second * 1) //等一秒在执行\n }\n \n //示例2：死循环\n for 2 > 1 {\n fmt.Println(2)\n time.Sleep(time.Second * 1) //等一秒在执行\n }\n \n //示例3\n number := 1\n for number < 5 { fmt.Println(\"爸爸\")\n number = 10 } //示例4\n i := 1\n for i < 5 {\n fmt.Println(\"爸爸\")\n i = i + 1\n }\n \n //示例5\n flag := true\n for flag {\n fmt.Println(\"我是你永远得不到的 爸爸\")\n flag = false\n }\n //错误语法\n // flag := 1\n // for flag {\n //fmt.Println(\"我是你永远得不到的 爸爸\")\n//flag = false\n//}\n//示例6 每次加1 也可以每次加2或*2\n for i := 1; i < 10; i = i + 1 {\n fmt.Print(i)\n }\n //示例7\n for i := 1; i < 10; i++ {\n fmt.Print(i)\n }\n//示例8 打标签循环continue\nf1:\n for i := 1; i < 3; i++ {\n for j := 1; j < 5; j++ {\n \n if j == 3 {\n continue f1\n }\n fmt.Println(i, j)\n }\n \n }\n//示例9 打标签循环break\n f2:\n for i := 1; i < 3; i++ {\n for j := 1; j < 5; j++ {\n \n if j == 3 {\n break f2\n }\n fmt.Println(i, j)\n }\n \n }\n "
        ]
    },
    "for range循环": {
        "prefix": "~for range",
        "body": [
            "//for range 循环\n //示例一\n arr3 := [3]int32{11, 22, 33}\n for key, item := range arr3 {\n fmt.Println(key, item)\n }\n \n //示例二\n for key := range arr3 {\n fmt.Println(key)\n }\n \n //示例三\n for _, item := range arr3 {\n fmt.Println(item)\n }\n"
        ]
    },
    "一维数组循环": {
        "prefix": "~for arr1",
        "body": [
            "var arr3 = [...]int{1, 2, 3, 4, 5}\n //for-range遍历二维数组\n for k, v := range arr3 {\n fmt.Println(k, v)\n }\n"
        ]
    },

    "二维数组循环": {
        "prefix": "~for arr2",
        "body": [
            "\n //for遍历二维数组\n var arr3 = [2][3]int{{1, 2, 3}, {4, 5, 6}}\n \n for i := 0; i < len(arr3); i++ {\n for j := 0; j < len(arr3[i]); j++ {\n fmt.Println(arr3[i][j])\n }\n }\n \n //for-range遍历二维数组\n for _, v := range arr3 {\n for _, v2 := range v {\n fmt.Println(v2)\n }\n }\n"
        ]
    },

























































        //------------------------------GO暂存代码------------------------------------------
        "存储用户输入的值": {
            "prefix": "!test",
            "body": [
                "//1.bufio.NewReader() 读取文件内容 ",
                "包bufio",
                "channel管道"

            ]
        },
        //------------------------------GO不懂的地方------------------------------------------
        //1.指针
}